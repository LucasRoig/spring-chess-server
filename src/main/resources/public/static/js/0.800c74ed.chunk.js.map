{"version":3,"sources":["../node_modules/tcomb/lib/assert.js","../node_modules/tcomb/lib/getTypeName.js","../node_modules/tcomb/lib/isFunction.js","../node_modules/tcomb/lib/isType.js","../node_modules/tcomb/lib/irreducible.js","../node_modules/tcomb/lib/isTypeName.js","../node_modules/tcomb/lib/isNil.js","../node_modules/tcomb/lib/isObject.js","../node_modules/tcomb/lib/isArray.js","../node_modules/tcomb/lib/isIdentity.js","../node_modules/tcomb/lib/create.js","../node_modules/tcomb/lib/is.js","../node_modules/tcomb/index.js","../node_modules/tcomb/lib/getFunctionName.js","../node_modules/tcomb/lib/forbidNewOperator.js","../node_modules/tcomb/lib/isString.js","../node_modules/tcomb/lib/isBoolean.js","../node_modules/tcomb/lib/Function.js","../node_modules/tcomb/lib/Any.js","../node_modules/tcomb/lib/isNumber.js","../node_modules/tcomb/lib/refinement.js","../node_modules/tcomb/lib/String.js","../node_modules/tcomb/lib/dict.js","../node_modules/tcomb/lib/mixin.js","../node_modules/tcomb/lib/stringify.js","../node_modules/tcomb/lib/Boolean.js","../node_modules/tcomb/lib/Nil.js","../node_modules/tcomb/lib/Number.js","../node_modules/tcomb/lib/isUnion.js","../node_modules/tcomb/lib/list.js","../node_modules/tcomb/lib/getDefaultInterfaceName.js","../node_modules/tcomb/lib/extend.js","../node_modules/tcomb/lib/tuple.js","../node_modules/tcomb/lib/assign.js","../node_modules/tcomb/lib/fail.js","../node_modules/tcomb/lib/Array.js","../node_modules/tcomb/lib/Date.js","../node_modules/tcomb/lib/Error.js","../node_modules/tcomb/lib/Integer.js","../node_modules/tcomb/lib/Object.js","../node_modules/tcomb/lib/RegExp.js","../node_modules/tcomb/lib/Type.js","../node_modules/tcomb/lib/declare.js","../node_modules/tcomb/lib/enums.js","../node_modules/tcomb/lib/maybe.js","../node_modules/tcomb/lib/isMaybe.js","../node_modules/tcomb/lib/struct.js","../node_modules/tcomb/lib/isStruct.js","../node_modules/tcomb/lib/isInterface.js","../node_modules/tcomb/lib/decompose.js","../node_modules/tcomb/lib/union.js","../node_modules/tcomb/lib/func.js","../node_modules/tcomb/lib/intersection.js","../node_modules/tcomb/lib/interface.js","../node_modules/tcomb/lib/update.js","../node_modules/tcomb/lib/match.js"],"names":["isFunction","__webpack_require__","isNil","fail","stringify","assert","guard","message","module","exports","isType","getFunctionName","ctor","displayName","x","isObject","meta","name","predicate","Irreducible","value","path","kind","identity","is","isString","isArray","Array","type","t","Any","Boolean","Date","Error","Function","Nil","Number","Integer","IntegerT","Object","RegExp","String","Type","TypeT","Arr","Bool","Dat","Err","Func","Num","Obj","Re","Str","dict","declare","enums","irreducible","list","maybe","refinement","struct","tuple","union","func","intersection","subtype","inter","update","mixin","getTypeName","match","f","length","isFinite","isNaN","isIdentity","create","getDefaultName","Refinement","instance","patch","domain","codomain","Dict","idempotent","ret","k","hasOwnProperty","actual","target","source","overwrite","replacer","key","JSON","e","isBoolean","isNumber","List","i","len","push","every","props","keys","map","prop","join","decompose","combinator","mixins","options","prototype","predicates","defaultProps","forEach","arr","elements","decomposition","unrefinedType","apply","getDefaultProps","getOptions","result","reduce","compose","strict","types","Tuple","expected","y","TypeError","isUnion","nextDeclareUniqueId","Declare","define","spec","dispatch","Enums","of","split","isMaybe","Maybe","getDefaultInterfaceName","extend","extendStruct","Struct","this","undefined","xs","concat","isRefinement","getPredicates","getUnrefinedType","Union","some","FunctionType","isInstrumented","instrumentation","getOptionalArgumentsIndex","end","areAllMaybes","domainLength","FuncType","curried","fn","args","slice","call","arguments","argsLength","g","bind","Intersection","assign","extendInterface","Interface","getShallowCopy","isCommand","commands","getCommand","newValue","isChanged","$apply","$push","$remove","obj","$set","$splice","splices","acc","splice","$swap","config","from","to","element","$unshift","$merge","whatToMerge"],"mappings":"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","file":"static/js/0.800c74ed.chunk.js","sourcesContent":["var isFunction = require('./isFunction');\n\nvar isNil = require('./isNil');\n\nvar fail = require('./fail');\n\nvar stringify = require('./stringify');\n\nfunction assert(guard, message) {\n  if (guard !== true) {\n    if (isFunction(message)) {\n      // handle lazy messages\n      message = message();\n    } else if (isNil(message)) {\n      // use a default message\n      message = 'Assert failed (turn on \"Pause on exceptions\" in your Source panel)';\n    }\n\n    assert.fail(message);\n  }\n}\n\nassert.fail = fail;\nassert.stringify = stringify;\nmodule.exports = assert;","var isType = require('./isType');\n\nvar getFunctionName = require('./getFunctionName');\n\nmodule.exports = function getTypeName(ctor) {\n  if (isType(ctor)) {\n    return ctor.displayName;\n  }\n\n  return getFunctionName(ctor);\n};","module.exports = function isFunction(x) {\n  return typeof x === 'function';\n};","var isFunction = require('./isFunction');\n\nvar isObject = require('./isObject');\n\nmodule.exports = function isType(x) {\n  return isFunction(x) && isObject(x.meta);\n};","var assert = require('./assert');\n\nvar isString = require('./isString');\n\nvar isFunction = require('./isFunction');\n\nvar forbidNewOperator = require('./forbidNewOperator');\n\nmodule.exports = function irreducible(name, predicate) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert(isString(name), function () {\n      return 'Invalid argument name ' + assert.stringify(name) + ' supplied to irreducible(name, predicate) (expected a string)';\n    });\n    assert(isFunction(predicate), 'Invalid argument predicate ' + assert.stringify(predicate) + ' supplied to irreducible(name, predicate) (expected a function)');\n  }\n\n  function Irreducible(value, path) {\n    if (process.env.NODE_ENV !== 'production') {\n      forbidNewOperator(this, Irreducible);\n      path = path || [name];\n      assert(predicate(value), function () {\n        return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/');\n      });\n    }\n\n    return value;\n  }\n\n  Irreducible.meta = {\n    kind: 'irreducible',\n    name: name,\n    predicate: predicate,\n    identity: true\n  };\n  Irreducible.displayName = name;\n  Irreducible.is = predicate;\n  return Irreducible;\n};","var isNil = require('./isNil');\n\nvar isString = require('./isString');\n\nmodule.exports = function isTypeName(name) {\n  return isNil(name) || isString(name);\n};","module.exports = function isNil(x) {\n  return x === null || x === void 0;\n};","var isNil = require('./isNil');\n\nvar isArray = require('./isArray');\n\nmodule.exports = function isObject(x) {\n  return !isNil(x) && typeof x === 'object' && !isArray(x);\n};","module.exports = function isArray(x) {\n  return Array.isArray ? Array.isArray(x) : x instanceof Array;\n};","var assert = require('./assert');\n\nvar Boolean = require('./Boolean');\n\nvar isType = require('./isType');\n\nvar getTypeName = require('./getTypeName'); // return true if the type constructor behaves like the identity function\n\n\nmodule.exports = function isIdentity(type) {\n  if (isType(type)) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(Boolean.is(type.meta.identity), function () {\n        return 'Invalid meta identity ' + assert.stringify(type.meta.identity) + ' supplied to type ' + getTypeName(type);\n      });\n    }\n\n    return type.meta.identity;\n  } // for tcomb the other constructors, like ES6 classes, are identity-like\n\n\n  return true;\n};","var isType = require('./isType');\n\nvar getFunctionName = require('./getFunctionName');\n\nvar assert = require('./assert');\n\nvar stringify = require('./stringify'); // creates an instance of a type, handling the optional new operator\n\n\nmodule.exports = function create(type, value, path) {\n  if (isType(type)) {\n    return !type.meta.identity && typeof value === 'object' && value !== null ? new type(value, path) : type(value, path);\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    // here type should be a class constructor and value some instance, just check membership and return the value\n    path = path || [getFunctionName(type)];\n    assert(value instanceof type, function () {\n      return 'Invalid value ' + stringify(value) + ' supplied to ' + path.join('/');\n    });\n  }\n\n  return value;\n};","var isType = require('./isType'); // returns true if x is an instance of type\n\n\nmodule.exports = function is(x, type) {\n  if (isType(type)) {\n    return type.is(x);\n  }\n\n  return x instanceof type; // type should be a class constructor\n};","/*! @preserve\n *\n * tcomb.js - Type checking and DDD for JavaScript\n *\n * The MIT License (MIT)\n *\n * Copyright (c) 2014-2016 Giulio Canti\n *\n */\n// core\nvar t = require('./lib/assert'); // types\n\n\nt.Any = require('./lib/Any');\nt.Array = require('./lib/Array');\nt.Boolean = require('./lib/Boolean');\nt.Date = require('./lib/Date');\nt.Error = require('./lib/Error');\nt.Function = require('./lib/Function');\nt.Nil = require('./lib/Nil');\nt.Number = require('./lib/Number');\nt.Integer = require('./lib/Integer');\nt.IntegerT = t.Integer;\nt.Object = require('./lib/Object');\nt.RegExp = require('./lib/RegExp');\nt.String = require('./lib/String');\nt.Type = require('./lib/Type');\nt.TypeT = t.Type; // short alias are deprecated\n\nt.Arr = t.Array;\nt.Bool = t.Boolean;\nt.Dat = t.Date;\nt.Err = t.Error;\nt.Func = t.Function;\nt.Num = t.Number;\nt.Obj = t.Object;\nt.Re = t.RegExp;\nt.Str = t.String; // combinators\n\nt.dict = require('./lib/dict');\nt.declare = require('./lib/declare');\nt.enums = require('./lib/enums');\nt.irreducible = require('./lib/irreducible');\nt.list = require('./lib/list');\nt.maybe = require('./lib/maybe');\nt.refinement = require('./lib/refinement');\nt.struct = require('./lib/struct');\nt.tuple = require('./lib/tuple');\nt.union = require('./lib/union');\nt.func = require('./lib/func');\nt.intersection = require('./lib/intersection');\nt.subtype = t.refinement;\nt.inter = require('./lib/interface'); // IE8 alias\n\nt['interface'] = t.inter; // functions\n\nt.assert = t;\nt.update = require('./lib/update');\nt.mixin = require('./lib/mixin');\nt.isType = require('./lib/isType');\nt.is = require('./lib/is');\nt.getTypeName = require('./lib/getTypeName');\nt.match = require('./lib/match');\nmodule.exports = t;","module.exports = function getFunctionName(f) {\n  return f.displayName || f.name || '<function' + f.length + '>';\n};","var assert = require('./assert');\n\nvar getTypeName = require('./getTypeName');\n\nmodule.exports = function forbidNewOperator(x, type) {\n  assert(!(x instanceof type), function () {\n    return 'Cannot use the new operator to instantiate the type ' + getTypeName(type);\n  });\n};","module.exports = function isString(x) {\n  return typeof x === 'string';\n};","module.exports = function isBoolean(x) {\n  return x === true || x === false;\n};","var irreducible = require('./irreducible');\n\nvar isFunction = require('./isFunction');\n\nmodule.exports = irreducible('Function', isFunction);","var irreducible = require('./irreducible');\n\nmodule.exports = irreducible('Any', function () {\n  return true;\n});","module.exports = function isNumber(x) {\n  return typeof x === 'number' && isFinite(x) && !isNaN(x);\n};","var assert = require('./assert');\n\nvar isTypeName = require('./isTypeName');\n\nvar isFunction = require('./isFunction');\n\nvar forbidNewOperator = require('./forbidNewOperator');\n\nvar isIdentity = require('./isIdentity');\n\nvar create = require('./create');\n\nvar is = require('./is');\n\nvar getTypeName = require('./getTypeName');\n\nvar getFunctionName = require('./getFunctionName');\n\nfunction getDefaultName(type, predicate) {\n  return '{' + getTypeName(type) + ' | ' + getFunctionName(predicate) + '}';\n}\n\nfunction refinement(type, predicate, name) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert(isFunction(type), function () {\n      return 'Invalid argument type ' + assert.stringify(type) + ' supplied to refinement(type, predicate, [name]) combinator (expected a type)';\n    });\n    assert(isFunction(predicate), function () {\n      return 'Invalid argument predicate supplied to refinement(type, predicate, [name]) combinator (expected a function)';\n    });\n    assert(isTypeName(name), function () {\n      return 'Invalid argument name ' + assert.stringify(name) + ' supplied to refinement(type, predicate, [name]) combinator (expected a string)';\n    });\n  }\n\n  var displayName = name || getDefaultName(type, predicate);\n  var identity = isIdentity(type);\n\n  function Refinement(value, path) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (identity) {\n        forbidNewOperator(this, Refinement);\n      }\n\n      path = path || [displayName];\n    }\n\n    var x = create(type, value, path);\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert(predicate(x), function () {\n        return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/');\n      });\n    }\n\n    return x;\n  }\n\n  Refinement.meta = {\n    kind: 'subtype',\n    type: type,\n    predicate: predicate,\n    name: name,\n    identity: identity\n  };\n  Refinement.displayName = displayName;\n\n  Refinement.is = function (x) {\n    return is(x, type) && predicate(x);\n  };\n\n  Refinement.update = function (instance, patch) {\n    return Refinement(assert.update(instance, patch));\n  };\n\n  return Refinement;\n}\n\nrefinement.getDefaultName = getDefaultName;\nmodule.exports = refinement;","var irreducible = require('./irreducible');\n\nvar isString = require('./isString');\n\nmodule.exports = irreducible('String', isString);","var assert = require('./assert');\n\nvar isTypeName = require('./isTypeName');\n\nvar isFunction = require('./isFunction');\n\nvar getTypeName = require('./getTypeName');\n\nvar isIdentity = require('./isIdentity');\n\nvar isObject = require('./isObject');\n\nvar create = require('./create');\n\nvar is = require('./is');\n\nfunction getDefaultName(domain, codomain) {\n  return '{[key: ' + getTypeName(domain) + ']: ' + getTypeName(codomain) + '}';\n}\n\nfunction dict(domain, codomain, name) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert(isFunction(domain), function () {\n      return 'Invalid argument domain ' + assert.stringify(domain) + ' supplied to dict(domain, codomain, [name]) combinator (expected a type)';\n    });\n    assert(isFunction(codomain), function () {\n      return 'Invalid argument codomain ' + assert.stringify(codomain) + ' supplied to dict(domain, codomain, [name]) combinator (expected a type)';\n    });\n    assert(isTypeName(name), function () {\n      return 'Invalid argument name ' + assert.stringify(name) + ' supplied to dict(domain, codomain, [name]) combinator (expected a string)';\n    });\n  }\n\n  var displayName = name || getDefaultName(domain, codomain);\n  var domainNameCache = getTypeName(domain);\n  var codomainNameCache = getTypeName(codomain);\n  var identity = isIdentity(domain) && isIdentity(codomain);\n\n  function Dict(value, path) {\n    if (process.env.NODE_ENV === 'production') {\n      if (identity) {\n        return value; // just trust the input if elements must not be hydrated\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      path = path || [displayName];\n      assert(isObject(value), function () {\n        return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/');\n      });\n    }\n\n    var idempotent = true; // will remain true if I can reutilise the input\n\n    var ret = {}; // make a temporary copy, will be discarded if idempotent remains true\n\n    for (var k in value) {\n      if (value.hasOwnProperty(k)) {\n        k = create(domain, k, process.env.NODE_ENV !== 'production' ? path.concat(domainNameCache) : null);\n        var actual = value[k];\n        var instance = create(codomain, actual, process.env.NODE_ENV !== 'production' ? path.concat(k + ': ' + codomainNameCache) : null);\n        idempotent = idempotent && actual === instance;\n        ret[k] = instance;\n      }\n    }\n\n    if (idempotent) {\n      // implements idempotency\n      ret = value;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      Object.freeze(ret);\n    }\n\n    return ret;\n  }\n\n  Dict.meta = {\n    kind: 'dict',\n    domain: domain,\n    codomain: codomain,\n    name: name,\n    identity: identity\n  };\n  Dict.displayName = displayName;\n\n  Dict.is = function (x) {\n    if (!isObject(x)) {\n      return false;\n    }\n\n    for (var k in x) {\n      if (x.hasOwnProperty(k)) {\n        if (!is(k, domain) || !is(x[k], codomain)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  };\n\n  Dict.update = function (instance, patch) {\n    return Dict(assert.update(instance, patch));\n  };\n\n  return Dict;\n}\n\ndict.getDefaultName = getDefaultName;\nmodule.exports = dict;","var isNil = require('./isNil');\n\nvar assert = require('./assert'); // safe mixin, cannot override props unless specified\n\n\nmodule.exports = function mixin(target, source, overwrite) {\n  if (isNil(source)) {\n    return target;\n  }\n\n  for (var k in source) {\n    if (source.hasOwnProperty(k)) {\n      if (overwrite !== true) {\n        if (process.env.NODE_ENV !== 'production') {\n          assert(!target.hasOwnProperty(k) || target[k] === source[k], function () {\n            return 'Invalid call to mixin(target, source, [overwrite]): cannot overwrite property \"' + k + '\" of target object';\n          });\n        }\n      }\n\n      target[k] = source[k];\n    }\n  }\n\n  return target;\n};","var getFunctionName = require('./getFunctionName');\n\nfunction replacer(key, value) {\n  if (typeof value === 'function') {\n    return getFunctionName(value);\n  }\n\n  return value;\n}\n\nmodule.exports = function stringify(x) {\n  try {\n    // handle \"Converting circular structure to JSON\" error\n    return JSON.stringify(x, replacer, 2);\n  } catch (e) {\n    return String(x);\n  }\n};","var irreducible = require('./irreducible');\n\nvar isBoolean = require('./isBoolean');\n\nmodule.exports = irreducible('Boolean', isBoolean);","var irreducible = require('./irreducible');\n\nvar isNil = require('./isNil');\n\nmodule.exports = irreducible('Nil', isNil);","var irreducible = require('./irreducible');\n\nvar isNumber = require('./isNumber');\n\nmodule.exports = irreducible('Number', isNumber);","var isType = require('./isType');\n\nmodule.exports = function isUnion(x) {\n  return isType(x) && x.meta.kind === 'union';\n};","var assert = require('./assert');\n\nvar isTypeName = require('./isTypeName');\n\nvar isFunction = require('./isFunction');\n\nvar getTypeName = require('./getTypeName');\n\nvar isIdentity = require('./isIdentity');\n\nvar create = require('./create');\n\nvar is = require('./is');\n\nvar isArray = require('./isArray');\n\nfunction getDefaultName(type) {\n  return 'Array<' + getTypeName(type) + '>';\n}\n\nfunction list(type, name) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert(isFunction(type), function () {\n      return 'Invalid argument type ' + assert.stringify(type) + ' supplied to list(type, [name]) combinator (expected a type)';\n    });\n    assert(isTypeName(name), function () {\n      return 'Invalid argument name ' + assert.stringify(name) + ' supplied to list(type, [name]) combinator (expected a string)';\n    });\n  }\n\n  var displayName = name || getDefaultName(type);\n  var typeNameCache = getTypeName(type);\n  var identity = isIdentity(type); // the list is identity iif type is identity\n\n  function List(value, path) {\n    if (process.env.NODE_ENV === 'production') {\n      if (identity) {\n        return value; // just trust the input if elements must not be hydrated\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      path = path || [displayName];\n      assert(isArray(value), function () {\n        return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/') + ' (expected an array of ' + typeNameCache + ')';\n      });\n    }\n\n    var idempotent = true; // will remain true if I can reutilise the input\n\n    var ret = []; // make a temporary copy, will be discarded if idempotent remains true\n\n    for (var i = 0, len = value.length; i < len; i++) {\n      var actual = value[i];\n      var instance = create(type, actual, process.env.NODE_ENV !== 'production' ? path.concat(i + ': ' + typeNameCache) : null);\n      idempotent = idempotent && actual === instance;\n      ret.push(instance);\n    }\n\n    if (idempotent) {\n      // implements idempotency\n      ret = value;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      Object.freeze(ret);\n    }\n\n    return ret;\n  }\n\n  List.meta = {\n    kind: 'list',\n    type: type,\n    name: name,\n    identity: identity\n  };\n  List.displayName = displayName;\n\n  List.is = function (x) {\n    return isArray(x) && x.every(function (e) {\n      return is(e, type);\n    });\n  };\n\n  List.update = function (instance, patch) {\n    return List(assert.update(instance, patch));\n  };\n\n  return List;\n}\n\nlist.getDefaultName = getDefaultName;\nmodule.exports = list;","var getTypeName = require('./getTypeName');\n\nfunction getDefaultInterfaceName(props) {\n  return '{' + Object.keys(props).map(function (prop) {\n    return prop + ': ' + getTypeName(props[prop]);\n  }).join(', ') + '}';\n}\n\nmodule.exports = getDefaultInterfaceName;","var assert = require('./assert');\n\nvar isFunction = require('./isFunction');\n\nvar isArray = require('./isArray');\n\nvar mixin = require('./mixin');\n\nvar isStruct = require('./isStruct');\n\nvar isInterface = require('./isInterface');\n\nvar isObject = require('./isObject');\n\nvar refinement = require('./refinement');\n\nvar decompose = require('./decompose');\n\nfunction compose(predicates, unrefinedType, name) {\n  var result = predicates.reduce(function (type, predicate) {\n    return refinement(type, predicate);\n  }, unrefinedType);\n\n  if (name) {\n    result.displayName = name;\n    result.meta.name = name;\n  }\n\n  return result;\n}\n\nfunction getProps(type) {\n  return isObject(type) ? type : type.meta.props;\n}\n\nfunction getDefaultProps(type) {\n  return isObject(type) ? null : type.meta.defaultProps;\n}\n\nfunction pushAll(arr, elements) {\n  Array.prototype.push.apply(arr, elements);\n}\n\nfunction extend(combinator, mixins, options) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert(isFunction(combinator), function () {\n      return 'Invalid argument combinator supplied to extend(combinator, mixins, options), expected a function';\n    });\n    assert(isArray(mixins), function () {\n      return 'Invalid argument mixins supplied to extend(combinator, mixins, options), expected an array';\n    });\n  }\n\n  var props = {};\n  var prototype = {};\n  var predicates = [];\n  var defaultProps = {};\n  mixins.forEach(function (x, i) {\n    var decomposition = decompose(x);\n    var unrefinedType = decomposition.unrefinedType;\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert(isObject(unrefinedType) || isStruct(unrefinedType) || isInterface(unrefinedType), function () {\n        return 'Invalid argument mixins[' + i + '] supplied to extend(combinator, mixins, options), expected an object, struct, interface or a refinement (of struct or interface)';\n      });\n    }\n\n    pushAll(predicates, decomposition.predicates);\n    mixin(props, getProps(unrefinedType));\n    mixin(prototype, unrefinedType.prototype);\n    mixin(defaultProps, getDefaultProps(unrefinedType), true);\n  });\n  options = combinator.getOptions(options);\n  options.defaultProps = mixin(defaultProps, options.defaultProps, true);\n  var result = compose(predicates, combinator(props, {\n    strict: options.strict,\n    defaultProps: options.defaultProps\n  }), options.name);\n  mixin(result.prototype, prototype);\n  return result;\n}\n\nmodule.exports = extend;","var assert = require('./assert');\n\nvar isTypeName = require('./isTypeName');\n\nvar isFunction = require('./isFunction');\n\nvar getTypeName = require('./getTypeName');\n\nvar isIdentity = require('./isIdentity');\n\nvar isArray = require('./isArray');\n\nvar create = require('./create');\n\nvar is = require('./is');\n\nfunction getDefaultName(types) {\n  return '[' + types.map(getTypeName).join(', ') + ']';\n}\n\nfunction tuple(types, name) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert(isArray(types) && types.every(isFunction), function () {\n      return 'Invalid argument types ' + assert.stringify(types) + ' supplied to tuple(types, [name]) combinator (expected an array of types)';\n    });\n    assert(isTypeName(name), function () {\n      return 'Invalid argument name ' + assert.stringify(name) + ' supplied to tuple(types, [name]) combinator (expected a string)';\n    });\n  }\n\n  var displayName = name || getDefaultName(types);\n  var identity = types.every(isIdentity);\n\n  function Tuple(value, path) {\n    if (process.env.NODE_ENV === 'production') {\n      if (identity) {\n        return value;\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      path = path || [displayName];\n      assert(isArray(value) && value.length === types.length, function () {\n        return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/') + ' (expected an array of length ' + types.length + ')';\n      });\n    }\n\n    var idempotent = true;\n    var ret = [];\n\n    for (var i = 0, len = types.length; i < len; i++) {\n      var expected = types[i];\n      var actual = value[i];\n      var instance = create(expected, actual, process.env.NODE_ENV !== 'production' ? path.concat(i + ': ' + getTypeName(expected)) : null);\n      idempotent = idempotent && actual === instance;\n      ret.push(instance);\n    }\n\n    if (idempotent) {\n      // implements idempotency\n      ret = value;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      Object.freeze(ret);\n    }\n\n    return ret;\n  }\n\n  Tuple.meta = {\n    kind: 'tuple',\n    types: types,\n    name: name,\n    identity: identity\n  };\n  Tuple.displayName = displayName;\n\n  Tuple.is = function (x) {\n    return isArray(x) && x.length === types.length && types.every(function (type, i) {\n      return is(x[i], type);\n    });\n  };\n\n  Tuple.update = function (instance, patch) {\n    return Tuple(assert.update(instance, patch));\n  };\n\n  return Tuple;\n}\n\ntuple.getDefaultName = getDefaultName;\nmodule.exports = tuple;","function assign(x, y) {\n  for (var k in y) {\n    if (y.hasOwnProperty(k)) {\n      x[k] = y[k];\n    }\n  }\n\n  return x;\n}\n\nmodule.exports = assign;","module.exports = function fail(message) {\n  throw new TypeError('[tcomb] ' + message);\n};","var irreducible = require('./irreducible');\n\nvar isArray = require('./isArray');\n\nmodule.exports = irreducible('Array', isArray);","var irreducible = require('./irreducible');\n\nmodule.exports = irreducible('Date', function (x) {\n  return x instanceof Date;\n});","var irreducible = require('./irreducible');\n\nmodule.exports = irreducible('Error', function (x) {\n  return x instanceof Error;\n});","var refinement = require('./refinement');\n\nvar Number = require('./Number');\n\nmodule.exports = refinement(Number, function (x) {\n  return x % 1 === 0;\n}, 'Integer');","var irreducible = require('./irreducible');\n\nvar isObject = require('./isObject');\n\nmodule.exports = irreducible('Object', isObject);","var irreducible = require('./irreducible');\n\nmodule.exports = irreducible('RegExp', function (x) {\n  return x instanceof RegExp;\n});","var irreducible = require('./irreducible');\n\nvar isType = require('./isType');\n\nmodule.exports = irreducible('Type', isType);","var assert = require('./assert');\n\nvar isTypeName = require('./isTypeName');\n\nvar isType = require('./isType');\n\nvar isNil = require('./isNil');\n\nvar mixin = require('./mixin');\n\nvar getTypeName = require('./getTypeName');\n\nvar isUnion = require('./isUnion'); // All the .declare-d types should be clearly different from each other thus they should have\n// different names when a name was not explicitly provided.\n\n\nvar nextDeclareUniqueId = 1;\n\nmodule.exports = function declare(name) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert(isTypeName(name), function () {\n      return 'Invalid argument name ' + name + ' supplied to declare([name]) (expected a string)';\n    });\n  }\n\n  var type;\n\n  function Declare(value, path) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(!isNil(type), function () {\n        return 'Type declared but not defined, don\\'t forget to call .define on every declared type';\n      });\n\n      if (isUnion(type)) {\n        assert(type.dispatch === Declare.dispatch, function () {\n          return 'Please define the custom ' + name + '.dispatch function before calling ' + name + '.define()';\n        });\n      }\n    }\n\n    return type(value, path);\n  }\n\n  Declare.define = function (spec) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(isType(spec), function () {\n        return 'Invalid argument type ' + assert.stringify(spec) + ' supplied to define(type) (expected a type)';\n      });\n      assert(isNil(type), function () {\n        return 'Declare.define(type) can only be invoked once';\n      }); // assert(isNil(spec.meta.name) && Object.keys(spec.prototype).length === 0, function () { return 'Invalid argument type ' + assert.stringify(spec) + ' supplied to define(type) (expected a fresh, unnamed type)'; });\n    }\n\n    if (isUnion(spec) && Declare.hasOwnProperty('dispatch')) {\n      spec.dispatch = Declare.dispatch;\n    }\n\n    type = spec;\n    mixin(Declare, type, true); // true because it overwrites Declare.displayName\n\n    if (name) {\n      type.displayName = Declare.displayName = name;\n      Declare.meta.name = name;\n    }\n\n    Declare.meta.identity = type.meta.identity;\n    Declare.prototype = type.prototype;\n    return Declare;\n  };\n\n  Declare.displayName = name || getTypeName(Declare) + \"$\" + nextDeclareUniqueId++; // in general I can't say if this type will be an identity, for safety setting to false\n\n  Declare.meta = {\n    identity: false\n  };\n  Declare.prototype = null;\n  return Declare;\n};","var assert = require('./assert');\n\nvar isTypeName = require('./isTypeName');\n\nvar forbidNewOperator = require('./forbidNewOperator');\n\nvar isNumber = require('./isNumber');\n\nvar isString = require('./isString');\n\nvar isObject = require('./isObject');\n\nfunction getDefaultName(map) {\n  return Object.keys(map).map(function (k) {\n    return assert.stringify(k);\n  }).join(' | ');\n}\n\nfunction enums(map, name) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert(isObject(map), function () {\n      return 'Invalid argument map ' + assert.stringify(map) + ' supplied to enums(map, [name]) combinator (expected a dictionary of String -> String | Number)';\n    });\n    assert(isTypeName(name), function () {\n      return 'Invalid argument name ' + assert.stringify(name) + ' supplied to enums(map, [name]) combinator (expected a string)';\n    });\n  }\n\n  var displayName = name || getDefaultName(map);\n\n  function Enums(value, path) {\n    if (process.env.NODE_ENV !== 'production') {\n      forbidNewOperator(this, Enums);\n      path = path || [displayName];\n      assert(Enums.is(value), function () {\n        return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/') + ' (expected one of ' + assert.stringify(Object.keys(map)) + ')';\n      });\n    }\n\n    return value;\n  }\n\n  Enums.meta = {\n    kind: 'enums',\n    map: map,\n    name: name,\n    identity: true\n  };\n  Enums.displayName = displayName;\n\n  Enums.is = function (x) {\n    return (isString(x) || isNumber(x)) && map.hasOwnProperty(x);\n  };\n\n  return Enums;\n}\n\nenums.of = function (keys, name) {\n  keys = isString(keys) ? keys.split(' ') : keys;\n  var value = {};\n  keys.forEach(function (k) {\n    value[k] = k;\n  });\n  return enums(value, name);\n};\n\nenums.getDefaultName = getDefaultName;\nmodule.exports = enums;","var assert = require('./assert');\n\nvar isTypeName = require('./isTypeName');\n\nvar isFunction = require('./isFunction');\n\nvar isMaybe = require('./isMaybe');\n\nvar isIdentity = require('./isIdentity');\n\nvar Any = require('./Any');\n\nvar create = require('./create');\n\nvar Nil = require('./Nil');\n\nvar forbidNewOperator = require('./forbidNewOperator');\n\nvar is = require('./is');\n\nvar getTypeName = require('./getTypeName');\n\nfunction getDefaultName(type) {\n  return '?' + getTypeName(type);\n}\n\nfunction maybe(type, name) {\n  if (isMaybe(type) || type === Any || type === Nil) {\n    // makes the combinator idempotent and handle Any, Nil\n    return type;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(isFunction(type), function () {\n      return 'Invalid argument type ' + assert.stringify(type) + ' supplied to maybe(type, [name]) combinator (expected a type)';\n    });\n    assert(isTypeName(name), function () {\n      return 'Invalid argument name ' + assert.stringify(name) + ' supplied to maybe(type, [name]) combinator (expected a string)';\n    });\n  }\n\n  var displayName = name || getDefaultName(type);\n  var identity = isIdentity(type);\n\n  function Maybe(value, path) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (identity) {\n        forbidNewOperator(this, Maybe);\n      }\n    }\n\n    return Nil.is(value) ? value : create(type, value, path);\n  }\n\n  Maybe.meta = {\n    kind: 'maybe',\n    type: type,\n    name: name,\n    identity: identity\n  };\n  Maybe.displayName = displayName;\n\n  Maybe.is = function (x) {\n    return Nil.is(x) || is(x, type);\n  };\n\n  return Maybe;\n}\n\nmaybe.getDefaultName = getDefaultName;\nmodule.exports = maybe;","var isType = require('./isType');\n\nmodule.exports = function isMaybe(x) {\n  return isType(x) && x.meta.kind === 'maybe';\n};","var assert = require('./assert');\n\nvar isTypeName = require('./isTypeName');\n\nvar String = require('./String');\n\nvar Function = require('./Function');\n\nvar isBoolean = require('./isBoolean');\n\nvar isObject = require('./isObject');\n\nvar isNil = require('./isNil');\n\nvar create = require('./create');\n\nvar getTypeName = require('./getTypeName');\n\nvar dict = require('./dict');\n\nvar getDefaultInterfaceName = require('./getDefaultInterfaceName');\n\nvar extend = require('./extend');\n\nfunction getDefaultName(props) {\n  return 'Struct' + getDefaultInterfaceName(props);\n}\n\nfunction extendStruct(mixins, name) {\n  return extend(struct, mixins, name);\n}\n\nfunction getOptions(options) {\n  if (!isObject(options)) {\n    options = isNil(options) ? {} : {\n      name: options\n    };\n  }\n\n  if (!options.hasOwnProperty('strict')) {\n    options.strict = struct.strict;\n  }\n\n  if (!options.hasOwnProperty('defaultProps')) {\n    options.defaultProps = {};\n  }\n\n  return options;\n}\n\nfunction struct(props, options) {\n  options = getOptions(options);\n  var name = options.name;\n  var strict = options.strict;\n  var defaultProps = options.defaultProps;\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(dict(String, Function).is(props), function () {\n      return 'Invalid argument props ' + assert.stringify(props) + ' supplied to struct(props, [options]) combinator (expected a dictionary String -> Type)';\n    });\n    assert(isTypeName(name), function () {\n      return 'Invalid argument name ' + assert.stringify(name) + ' supplied to struct(props, [options]) combinator (expected a string)';\n    });\n    assert(isBoolean(strict), function () {\n      return 'Invalid argument strict ' + assert.stringify(strict) + ' supplied to struct(props, [options]) combinator (expected a boolean)';\n    });\n    assert(isObject(defaultProps), function () {\n      return 'Invalid argument defaultProps ' + assert.stringify(defaultProps) + ' supplied to struct(props, [options]) combinator (expected an object)';\n    });\n  }\n\n  var displayName = name || getDefaultName(props);\n\n  function Struct(value, path) {\n    if (Struct.is(value)) {\n      // implements idempotency\n      return value;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      path = path || [displayName];\n      assert(isObject(value), function () {\n        return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/') + ' (expected an object)';\n      }); // strictness\n\n      if (strict) {\n        for (k in value) {\n          if (value.hasOwnProperty(k)) {\n            assert(props.hasOwnProperty(k), function () {\n              return 'Invalid additional prop \"' + k + '\" supplied to ' + path.join('/');\n            });\n          }\n        }\n      }\n    }\n\n    if (!(this instanceof Struct)) {\n      // `new` is optional\n      return new Struct(value, path);\n    }\n\n    for (var k in props) {\n      if (props.hasOwnProperty(k)) {\n        var expected = props[k];\n        var actual = value[k]; // apply defaults\n\n        if (actual === undefined) {\n          actual = defaultProps[k];\n        }\n\n        this[k] = create(expected, actual, process.env.NODE_ENV !== 'production' ? path.concat(k + ': ' + getTypeName(expected)) : null);\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      Object.freeze(this);\n    }\n  }\n\n  Struct.meta = {\n    kind: 'struct',\n    props: props,\n    name: name,\n    identity: false,\n    strict: strict,\n    defaultProps: defaultProps\n  };\n  Struct.displayName = displayName;\n\n  Struct.is = function (x) {\n    return x instanceof Struct;\n  };\n\n  Struct.update = function (instance, patch) {\n    return new Struct(assert.update(instance, patch));\n  };\n\n  Struct.extend = function (xs, name) {\n    return extendStruct([Struct].concat(xs), name);\n  };\n\n  return Struct;\n}\n\nstruct.strict = false;\nstruct.getOptions = getOptions;\nstruct.getDefaultName = getDefaultName;\nstruct.extend = extendStruct;\nmodule.exports = struct;","var isType = require('./isType');\n\nmodule.exports = function isStruct(x) {\n  return isType(x) && x.meta.kind === 'struct';\n};","var isType = require('./isType');\n\nmodule.exports = function isInterface(x) {\n  return isType(x) && x.meta.kind === 'interface';\n};","var isType = require('./isType');\n\nfunction isRefinement(type) {\n  return isType(type) && type.meta.kind === 'subtype';\n}\n\nfunction getPredicates(type) {\n  return isRefinement(type) ? [type.meta.predicate].concat(getPredicates(type.meta.type)) : [];\n}\n\nfunction getUnrefinedType(type) {\n  return isRefinement(type) ? getUnrefinedType(type.meta.type) : type;\n}\n\nfunction decompose(type) {\n  return {\n    predicates: getPredicates(type),\n    unrefinedType: getUnrefinedType(type)\n  };\n}\n\nmodule.exports = decompose;","var assert = require('./assert');\n\nvar isTypeName = require('./isTypeName');\n\nvar isFunction = require('./isFunction');\n\nvar getTypeName = require('./getTypeName');\n\nvar isIdentity = require('./isIdentity');\n\nvar isArray = require('./isArray');\n\nvar create = require('./create');\n\nvar is = require('./is');\n\nvar forbidNewOperator = require('./forbidNewOperator');\n\nvar isUnion = require('./isUnion');\n\nvar isNil = require('./isNil');\n\nfunction getDefaultName(types) {\n  return types.map(getTypeName).join(' | ');\n}\n\nfunction union(types, name) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert(isArray(types) && types.every(isFunction) && types.length >= 2, function () {\n      return 'Invalid argument types ' + assert.stringify(types) + ' supplied to union(types, [name]) combinator (expected an array of at least 2 types)';\n    });\n    assert(isTypeName(name), function () {\n      return 'Invalid argument name ' + assert.stringify(name) + ' supplied to union(types, [name]) combinator (expected a string)';\n    });\n  }\n\n  var displayName = name || getDefaultName(types);\n  var identity = types.every(isIdentity);\n\n  function Union(value, path) {\n    if (process.env.NODE_ENV === 'production') {\n      if (identity) {\n        return value;\n      }\n    }\n\n    var type = Union.dispatch(value);\n\n    if (!type && Union.is(value)) {\n      return value;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (identity) {\n        forbidNewOperator(this, Union);\n      }\n\n      path = path || [displayName];\n      assert(isFunction(type), function () {\n        return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/') + ' (no constructor returned by dispatch)';\n      });\n      path[path.length - 1] += '(' + getTypeName(type) + ')';\n    }\n\n    return create(type, value, path);\n  }\n\n  Union.meta = {\n    kind: 'union',\n    types: types,\n    name: name,\n    identity: identity\n  };\n  Union.displayName = displayName;\n\n  Union.is = function (x) {\n    return types.some(function (type) {\n      return is(x, type);\n    });\n  };\n\n  Union.dispatch = function (x) {\n    // default dispatch implementation\n    for (var i = 0, len = types.length; i < len; i++) {\n      var type = types[i];\n\n      if (isUnion(type)) {\n        // handle union of unions\n        var t = type.dispatch(x);\n\n        if (!isNil(t)) {\n          return t;\n        }\n      } else if (is(x, type)) {\n        return type;\n      }\n    }\n  };\n\n  Union.update = function (instance, patch) {\n    return Union(assert.update(instance, patch));\n  };\n\n  return Union;\n}\n\nunion.getDefaultName = getDefaultName;\nmodule.exports = union;","var assert = require('./assert');\n\nvar isTypeName = require('./isTypeName');\n\nvar FunctionType = require('./Function');\n\nvar isArray = require('./isArray');\n\nvar list = require('./list');\n\nvar isObject = require('./isObject');\n\nvar create = require('./create');\n\nvar isNil = require('./isNil');\n\nvar isBoolean = require('./isBoolean');\n\nvar tuple = require('./tuple');\n\nvar getFunctionName = require('./getFunctionName');\n\nvar getTypeName = require('./getTypeName');\n\nvar isType = require('./isType');\n\nfunction getDefaultName(domain, codomain) {\n  return '(' + domain.map(getTypeName).join(', ') + ') => ' + getTypeName(codomain);\n}\n\nfunction isInstrumented(f) {\n  return FunctionType.is(f) && isObject(f.instrumentation);\n}\n\nfunction getOptionalArgumentsIndex(types) {\n  var end = types.length;\n  var areAllMaybes = false;\n\n  for (var i = end - 1; i >= 0; i--) {\n    var type = types[i];\n\n    if (!isType(type) || type.meta.kind !== 'maybe') {\n      return i + 1;\n    } else {\n      areAllMaybes = true;\n    }\n  }\n\n  return areAllMaybes ? 0 : end;\n}\n\nfunction func(domain, codomain, name) {\n  domain = isArray(domain) ? domain : [domain]; // handle handy syntax for unary functions\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(list(FunctionType).is(domain), function () {\n      return 'Invalid argument domain ' + assert.stringify(domain) + ' supplied to func(domain, codomain, [name]) combinator (expected an array of types)';\n    });\n    assert(FunctionType.is(codomain), function () {\n      return 'Invalid argument codomain ' + assert.stringify(codomain) + ' supplied to func(domain, codomain, [name]) combinator (expected a type)';\n    });\n    assert(isTypeName(name), function () {\n      return 'Invalid argument name ' + assert.stringify(name) + ' supplied to func(domain, codomain, [name]) combinator (expected a string)';\n    });\n  }\n\n  var displayName = name || getDefaultName(domain, codomain);\n  var domainLength = domain.length;\n  var optionalArgumentsIndex = getOptionalArgumentsIndex(domain);\n\n  function FuncType(value, path) {\n    if (!isInstrumented(value)) {\n      // automatically instrument the function\n      return FuncType.of(value);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      path = path || [displayName];\n      assert(FuncType.is(value), function () {\n        return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/');\n      });\n    }\n\n    return value;\n  }\n\n  FuncType.meta = {\n    kind: 'func',\n    domain: domain,\n    codomain: codomain,\n    name: name,\n    identity: true\n  };\n  FuncType.displayName = displayName;\n\n  FuncType.is = function (x) {\n    return isInstrumented(x) && x.instrumentation.domain.length === domainLength && x.instrumentation.domain.every(function (type, i) {\n      return type === domain[i];\n    }) && x.instrumentation.codomain === codomain;\n  };\n\n  FuncType.of = function (f, curried) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(FunctionType.is(f), function () {\n        return 'Invalid argument f supplied to func.of ' + displayName + ' (expected a function)';\n      });\n      assert(isNil(curried) || isBoolean(curried), function () {\n        return 'Invalid argument curried ' + assert.stringify(curried) + ' supplied to func.of ' + displayName + ' (expected a boolean)';\n      });\n    }\n\n    if (FuncType.is(f)) {\n      // makes FuncType.of idempotent\n      return f;\n    }\n\n    function fn() {\n      var args = Array.prototype.slice.call(arguments);\n      var argsLength = args.length;\n\n      if (process.env.NODE_ENV !== 'production') {\n        // type-check arguments\n        var tupleLength = curried ? argsLength : Math.max(argsLength, optionalArgumentsIndex);\n        tuple(domain.slice(0, tupleLength), 'arguments of function ' + displayName)(args);\n      }\n\n      if (curried && argsLength < domainLength) {\n        if (process.env.NODE_ENV !== 'production') {\n          assert(argsLength > 0, 'Invalid arguments.length = 0 for curried function ' + displayName);\n        }\n\n        var g = Function.prototype.bind.apply(f, [this].concat(args));\n        var newDomain = func(domain.slice(argsLength), codomain);\n        return newDomain.of(g, true);\n      } else {\n        return create(codomain, f.apply(this, args));\n      }\n    }\n\n    fn.instrumentation = {\n      domain: domain,\n      codomain: codomain,\n      f: f\n    };\n    fn.displayName = getFunctionName(f);\n    return fn;\n  };\n\n  return FuncType;\n}\n\nfunc.getDefaultName = getDefaultName;\nfunc.getOptionalArgumentsIndex = getOptionalArgumentsIndex;\nmodule.exports = func;","var assert = require('./assert');\n\nvar isTypeName = require('./isTypeName');\n\nvar isFunction = require('./isFunction');\n\nvar isArray = require('./isArray');\n\nvar forbidNewOperator = require('./isIdentity');\n\nvar is = require('./is');\n\nvar getTypeName = require('./getTypeName');\n\nvar isIdentity = require('./isIdentity');\n\nfunction getDefaultName(types) {\n  return types.map(getTypeName).join(' & ');\n}\n\nfunction intersection(types, name) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert(isArray(types) && types.every(isFunction) && types.length >= 2, function () {\n      return 'Invalid argument types ' + assert.stringify(types) + ' supplied to intersection(types, [name]) combinator (expected an array of at least 2 types)';\n    });\n    assert(isTypeName(name), function () {\n      return 'Invalid argument name ' + assert.stringify(name) + ' supplied to intersection(types, [name]) combinator (expected a string)';\n    });\n  }\n\n  var displayName = name || getDefaultName(types);\n  var identity = types.every(isIdentity);\n\n  function Intersection(value, path) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (identity) {\n        forbidNewOperator(this, Intersection);\n      }\n\n      path = path || [displayName];\n      assert(Intersection.is(value), function () {\n        return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/');\n      });\n    }\n\n    return value;\n  }\n\n  Intersection.meta = {\n    kind: 'intersection',\n    types: types,\n    name: name,\n    identity: identity\n  };\n  Intersection.displayName = displayName;\n\n  Intersection.is = function (x) {\n    return types.every(function (type) {\n      return is(x, type);\n    });\n  };\n\n  Intersection.update = function (instance, patch) {\n    return Intersection(assert.update(instance, patch));\n  };\n\n  return Intersection;\n}\n\nintersection.getDefaultName = getDefaultName;\nmodule.exports = intersection;","var assert = require('./assert');\n\nvar isTypeName = require('./isTypeName');\n\nvar String = require('./String');\n\nvar Function = require('./Function');\n\nvar isBoolean = require('./isBoolean');\n\nvar isObject = require('./isObject');\n\nvar isNil = require('./isNil');\n\nvar create = require('./create');\n\nvar getTypeName = require('./getTypeName');\n\nvar dict = require('./dict');\n\nvar getDefaultInterfaceName = require('./getDefaultInterfaceName');\n\nvar isIdentity = require('./isIdentity');\n\nvar is = require('./is');\n\nvar extend = require('./extend');\n\nvar assign = require('./assign');\n\nfunction extendInterface(mixins, name) {\n  return extend(inter, mixins, name);\n}\n\nfunction getOptions(options) {\n  if (!isObject(options)) {\n    options = isNil(options) ? {} : {\n      name: options\n    };\n  }\n\n  if (!options.hasOwnProperty('strict')) {\n    options.strict = inter.strict;\n  }\n\n  return options;\n}\n\nfunction inter(props, options) {\n  options = getOptions(options);\n  var name = options.name;\n  var strict = options.strict;\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(dict(String, Function).is(props), function () {\n      return 'Invalid argument props ' + assert.stringify(props) + ' supplied to interface(props, [options]) combinator (expected a dictionary String -> Type)';\n    });\n    assert(isTypeName(name), function () {\n      return 'Invalid argument name ' + assert.stringify(name) + ' supplied to interface(props, [options]) combinator (expected a string)';\n    });\n    assert(isBoolean(strict), function () {\n      return 'Invalid argument strict ' + assert.stringify(strict) + ' supplied to struct(props, [options]) combinator (expected a boolean)';\n    });\n  }\n\n  var displayName = name || getDefaultInterfaceName(props);\n  var identity = Object.keys(props).map(function (prop) {\n    return props[prop];\n  }).every(isIdentity);\n\n  function Interface(value, path) {\n    if (process.env.NODE_ENV === 'production') {\n      if (identity) {\n        return value; // just trust the input if elements must not be hydrated\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      path = path || [displayName];\n      assert(!isNil(value), function () {\n        return 'Invalid value ' + value + ' supplied to ' + path.join('/');\n      }); // strictness\n\n      if (strict) {\n        for (var k in value) {\n          assert(props.hasOwnProperty(k), function () {\n            return 'Invalid additional prop \"' + k + '\" supplied to ' + path.join('/');\n          });\n        }\n      }\n    }\n\n    var idempotent = true;\n    var ret = identity ? {} : assign({}, value);\n\n    for (var prop in props) {\n      var expected = props[prop];\n      var actual = value[prop];\n      var instance = create(expected, actual, process.env.NODE_ENV !== 'production' ? path.concat(prop + ': ' + getTypeName(expected)) : null);\n      idempotent = idempotent && actual === instance;\n      ret[prop] = instance;\n    }\n\n    if (idempotent) {\n      // implements idempotency\n      ret = value;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      Object.freeze(ret);\n    }\n\n    return ret;\n  }\n\n  Interface.meta = {\n    kind: 'interface',\n    props: props,\n    name: name,\n    identity: identity,\n    strict: strict\n  };\n  Interface.displayName = displayName;\n\n  Interface.is = function (x) {\n    if (isNil(x)) {\n      return false;\n    }\n\n    if (strict) {\n      for (var k in x) {\n        if (!props.hasOwnProperty(k)) {\n          return false;\n        }\n      }\n    }\n\n    for (var prop in props) {\n      if (!is(x[prop], props[prop])) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  Interface.update = function (instance, patch) {\n    return Interface(assert.update(instance, patch));\n  };\n\n  Interface.extend = function (xs, name) {\n    return extendInterface([Interface].concat(xs), name);\n  };\n\n  return Interface;\n}\n\ninter.strict = false;\ninter.getOptions = getOptions;\ninter.getDefaultName = getDefaultInterfaceName;\ninter.extend = extendInterface;\nmodule.exports = inter;","var assert = require('./assert');\n\nvar isObject = require('./isObject');\n\nvar isFunction = require('./isFunction');\n\nvar isArray = require('./isArray');\n\nvar isNumber = require('./isNumber');\n\nvar assign = require('./assign');\n\nfunction getShallowCopy(x) {\n  if (isObject(x)) {\n    if (x instanceof Date || x instanceof RegExp) {\n      return x;\n    }\n\n    return assign({}, x);\n  }\n\n  if (isArray(x)) {\n    return x.concat();\n  }\n\n  return x;\n}\n\nfunction isCommand(k) {\n  return update.commands.hasOwnProperty(k);\n}\n\nfunction getCommand(k) {\n  return update.commands[k];\n}\n\nfunction update(instance, patch) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert(isObject(patch), function () {\n      return 'Invalid argument patch ' + assert.stringify(patch) + ' supplied to function update(instance, patch): expected an object containing commands';\n    });\n  }\n\n  var value = instance;\n  var isChanged = false;\n  var newValue;\n\n  for (var k in patch) {\n    if (patch.hasOwnProperty(k)) {\n      if (isCommand(k)) {\n        newValue = getCommand(k)(patch[k], value);\n\n        if (newValue !== instance) {\n          isChanged = true;\n          value = newValue;\n        } else {\n          value = instance;\n        }\n      } else {\n        if (value === instance) {\n          value = getShallowCopy(instance);\n        }\n\n        newValue = update(value[k], patch[k]);\n        isChanged = isChanged || newValue !== value[k];\n        value[k] = newValue;\n      }\n    }\n  }\n\n  return isChanged ? value : instance;\n} // built-in commands\n\n\nfunction $apply(f, value) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert(isFunction(f), 'Invalid argument f supplied to immutability helper { $apply: f } (expected a function)');\n  }\n\n  return f(value);\n}\n\nfunction $push(elements, arr) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert(isArray(elements), 'Invalid argument elements supplied to immutability helper { $push: elements } (expected an array)');\n    assert(isArray(arr), 'Invalid value supplied to immutability helper $push (expected an array)');\n  }\n\n  if (elements.length > 0) {\n    return arr.concat(elements);\n  }\n\n  return arr;\n}\n\nfunction $remove(keys, obj) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert(isArray(keys), 'Invalid argument keys supplied to immutability helper { $remove: keys } (expected an array)');\n    assert(isObject(obj), 'Invalid value supplied to immutability helper $remove (expected an object)');\n  }\n\n  if (keys.length > 0) {\n    obj = getShallowCopy(obj);\n\n    for (var i = 0, len = keys.length; i < len; i++) {\n      delete obj[keys[i]];\n    }\n  }\n\n  return obj;\n}\n\nfunction $set(value) {\n  return value;\n}\n\nfunction $splice(splices, arr) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert(isArray(splices) && splices.every(isArray), 'Invalid argument splices supplied to immutability helper { $splice: splices } (expected an array of arrays)');\n    assert(isArray(arr), 'Invalid value supplied to immutability helper $splice (expected an array)');\n  }\n\n  if (splices.length > 0) {\n    arr = getShallowCopy(arr);\n    return splices.reduce(function (acc, splice) {\n      acc.splice.apply(acc, splice);\n      return acc;\n    }, arr);\n  }\n\n  return arr;\n}\n\nfunction $swap(config, arr) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert(isObject(config), 'Invalid argument config supplied to immutability helper { $swap: config } (expected an object)');\n    assert(isNumber(config.from), 'Invalid argument config.from supplied to immutability helper { $swap: config } (expected a number)');\n    assert(isNumber(config.to), 'Invalid argument config.to supplied to immutability helper { $swap: config } (expected a number)');\n    assert(isArray(arr), 'Invalid value supplied to immutability helper $swap (expected an array)');\n  }\n\n  if (config.from !== config.to) {\n    arr = getShallowCopy(arr);\n    var element = arr[config.to];\n    arr[config.to] = arr[config.from];\n    arr[config.from] = element;\n  }\n\n  return arr;\n}\n\nfunction $unshift(elements, arr) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert(isArray(elements), 'Invalid argument elements supplied to immutability helper {$unshift: elements} (expected an array)');\n    assert(isArray(arr), 'Invalid value supplied to immutability helper $unshift (expected an array)');\n  }\n\n  if (elements.length > 0) {\n    return elements.concat(arr);\n  }\n\n  return arr;\n}\n\nfunction $merge(whatToMerge, value) {\n  var isChanged = false;\n  var result = getShallowCopy(value);\n\n  for (var k in whatToMerge) {\n    if (whatToMerge.hasOwnProperty(k)) {\n      result[k] = whatToMerge[k];\n      isChanged = isChanged || result[k] !== value[k];\n    }\n  }\n\n  return isChanged ? result : value;\n}\n\nupdate.commands = {\n  $apply: $apply,\n  $push: $push,\n  $remove: $remove,\n  $set: $set,\n  $splice: $splice,\n  $swap: $swap,\n  $unshift: $unshift,\n  $merge: $merge\n};\nmodule.exports = update;","var assert = require('./assert');\n\nvar isFunction = require('./isFunction');\n\nvar isType = require('./isType');\n\nvar Any = require('./Any');\n\nmodule.exports = function match(x) {\n  var type, guard, f, count;\n\n  for (var i = 1, len = arguments.length; i < len;) {\n    type = arguments[i];\n    guard = arguments[i + 1];\n    f = arguments[i + 2];\n\n    if (isFunction(f) && !isType(f)) {\n      i = i + 3;\n    } else {\n      f = guard;\n      guard = Any.is;\n      i = i + 2;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      count = (count || 0) + 1;\n      assert(isType(type), function () {\n        return 'Invalid type in clause #' + count;\n      });\n      assert(isFunction(guard), function () {\n        return 'Invalid guard in clause #' + count;\n      });\n      assert(isFunction(f), function () {\n        return 'Invalid block in clause #' + count;\n      });\n    }\n\n    if (type.is(x) && guard(x)) {\n      return f(x);\n    }\n  }\n\n  assert.fail('Match error');\n};"],"sourceRoot":""}